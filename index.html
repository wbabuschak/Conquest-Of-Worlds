<!DOCTYPE html>
<html>
<body>
    <div id="tooltip" style ="display: none"></div>
    <div id="top-content" style="flex-grow: 1; justify-content: space-between; display: flex; max-width: 100%; height: max-content; width: max-content;  margin: 0vw 1vw; gap: 1vw;   font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif ;">
        <script>
            const currentVersion = "0.1.0";
            const savedVersion = localStorage.getItem("gameVersion");
            if (savedVersion !== currentVersion) {
                localStorage.setItem("gameVersion", currentVersion);
                location.reload(true);
            }
        </script>
        <div style ="border-radius: 1vw; background-color: #00000060; padding: 0.5vw 1vw;">
            <title id = "title">Conquest of Worlds</title>
            <h1 id = "gameTitle">Conquest of Worlds</h1>
            <p>By William Babuschak</p>
        </div>
        
        <script>
            document.getElementById("title").innerHTML += " " + currentVersion; 
            document.getElementById("gameTitle").innerHTML += " " + currentVersion;
        </script>   
        <div style ="border-radius: 1vw; background-color: #00000060; padding: 0.5vw 1vw;">
            <h2>Volume</h2>
            <input type="range" id="volumeSlider" min="0" max="100" value="50"></input>
        </div>
        <div style ="border-radius: 1vw; background-color: #00000060; padding: 0.5vw 1vw;">
            <p id="xpText">Level: 0 XP: 0 / 0</p>
            <div id="xpContainer" style="width: 250; height: 25px; background: #ffffff; overflow: hidden; box-shadow: inset 0 0 2px #000;">
                <div id="xpBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #1649b8ff, #a6b4d3ff); transition: width 0.3s ease;"></div>
            </div>
        </div>
          
        <div style ="border-radius: 1vw; background-color: #00000060; padding: 0.5vw 1vw;">
            <p id="worldTimer"></p>
            <select id="worldSelect"></select>
            <p id="knownWorlds">1 / 17</p>
        </div>
        <div style ="border-radius: 1vw; background-color: #00000060; padding: 0.5vw 1vw;">
            <p>Hunting: </p>
            <select id="enemySelect"></select>
        </div>
        
        <button id="resetButton">Reset Save Data</button>
        
    </div>
    <div id="main-container" style="display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; padding:1vw; font-size: 18px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif ;">

    
    <div id="left-content" style="flex-grow: 1; max-width: 32%; width: max-content; background-color: #00000020; padding: 1vw; border-radius: 1vw;">
        <p id = "entityDisplay"></p>
        <p id = "lootDisplay">&nbsp;</p>
        <button id="attackButton">Attack!</button>
        <p id = "dpsDisplay"></p>
        <p id = "dropTableDisplay"></p>
    </div>
    <div id="middle-content" style="flex-grow: 1; max-width: 32%; width: max-content; background-color: #00000020; padding: 1vw; border-radius: 1vw;">
        <button id="equipButton">Equip</button>
        <select id="equipSelect"></select>
        <p></p>
        <button id="unequipButton">Unquip</button>
        <select id="unequipSelect"></select>
        <p id = "equippedItems"></p>
    </div>
    <div id="right-content" style="flex-grow: 1; max-width: 32%; width: max-content;">
        <div id="crafting-content" style="background-color: #00000020; padding: 1vw; border-radius: 1vw;">
            <p id = "craftDisplay"></p>
            <button id = "recipeToggle">Hide Recipes</button>
        </div>
        <div id="recipe-content" style="background-color: #00000020; margin: 1vw 0vw; padding: 1vw; border-radius: 1vw;">
            <p id = "recipeDisplay"></p>
        </div>
        <p id = "inventory" style="background-color: #00000020; margin: 1vw 0vw; padding: 1vw; border-radius: 1vw;"></p>
    </div>
    
    <script src="entity.js?v=1.0"></script>
    <script src="item.js?v=1.0"></script>
    <script src="loot_table.js?v=1.0"></script>
    <script src="inventory.js?v=1.0"></script>
    <script src="loot_tables.js?v=1.0"></script>
    <script src="enemies.js?v=1.0"></script>
    <script src="recipe.js?v=1.0"></script>
    <script src="recipes.js?v=1.0"></script>
    <script src="item_effects.js?v=1.0"></script>
    <script src="utility.js?v=1.0"></script>
    <script src="worlds.js?v=1.0"></script>

    <style>
        #entityDisplay {
            font-size: 24px;
        }
        #attackButton {
            font-size: 36px;
            padding: 12px 24px;
            font-weight: bold;
        }
        #resetButton {
            position: absolute;
            top: 0;
            right: 0;
        }
        #equipButton {
            width: 84px;
            height: 30px;
            font-size: 16px;
            font-weight: bold;
            vertical-align: middle;
        }
        #unequipButton {
            width: 84px;
            height: 30px;
            font-size: 16px;
            font-weight: bold;
            vertical-align: middle;
        }
        #equipSelect {
            height: 30px;
            vertical-align: middle;
        }
        #unequipSelect {
            height: 30px;
            vertical-align: middle;
        }
        #saveButton {
            font-weight: bold;
        }
        #lootDisplay{
            min-height: 1em;
            line-height: 1em;
        }
        #tooltip{
            position: absolute;
            background: #ffffff;
            border: 2px solid #000;
            opacity: 0.95;
            padding: 3px;
        }
        #inventory{
            white-space: "no-wrap";
        }
    </style>

    <script>
        // const worldMusic = {
        //     0: "music/Live-Today.wav",
        //     1: "music/Wasted-Time.wav",
        //     2: "music/Thinking-Of-You.wav",
        //     7: "music/Overdose.wav",
        // }
        
        let activeEntity;
        let inventory = new Inventory;
        let equipped = [];
        let autoMode = false;
        let autoInterval;
        let attackCount = 0;
        let enemyAttacks = 0;
        let lastHits = [];
        let kills = 0;
        let dropCount = 1;
        // let music = false;
        let volume;

        let precomputedDamage = {
            baseDmg: 1,
            dmgMult: 1.0,
            moreMult: 1.0,
            missChance: 0.0,
            missMult: 0.0,
            arcaneCount: 0,
            arcaneSetBonus: 0,
            starSetBonus: 0,
            setBase: -1
        };

        let experience = 0;
        let level = 0;

        function gainExperience(entity){
            let xp_to_level = 2 * (1 + level) * (1 + level) * (20 + level);
            if (entity){
                let exp = entity.xp;
                if (entity.mobLevel >= level){
                    experience += exp;
                    // document.getElementById("xpText").style.color = "";
                } else {
                    // document.getElementById("xpText").style.color = "#c5c5c5ff";
                }
                
                
                while (experience >= xp_to_level){
                    experience -= xp_to_level;
                    level++;
                    
                    xp_to_level = 2 * (1 + level) * (1 + level) * (20 + level);
                }
            }
            
            document.getElementById("xpBar").style.width = (100 * experience / xp_to_level) + '%';
            document.getElementById("xpText").innerHTML =`Level: ${level}<br>XP: ${experience } / ${xp_to_level}`;
        }

        gainExperience();

        function updateInventory(){
            const inventoryElement = document.getElementById("inventory");
            if (inventory.items.length == 0) {
                inventoryElement.textContent = "Inventory is empty.";
            } else {
                inventoryElement.replaceChildren(inventory.list());
            }
            updateRecipesDisplays();
            updateEquipSelect();
            updateUnequipSelect();
            updateWorldSelect();
            saveGame();
        }
        function updateEquipped(){
            const equippedElement = document.getElementById("equippedItems");
            if (!equipped.length) {
                equippedElement.textContent = "No items equipped.";
            } else {
                equippedElement.innerHTML = "";
                equipped.sort((a,b) => orderedSlots.indexOf(a.equippable) - orderedSlots.indexOf(b.equippable));
                equipped.forEach(item => {
                    
                    const wrapper = document.createElement("span");
                    const type = item.equippable;

                    const typeSpan = document.createElement("span");
                    typeSpan.textContent = type + "- ";
                    typeSpan.style.color = "";
                    wrapper.appendChild(typeSpan);

                    const temp = { items: [item], list: Inventory.prototype.list };
                    const itemFragment = temp.list.call({ items: [item], }, false);
                    wrapper.appendChild(itemFragment);

                    equippedElement.appendChild(wrapper);
                    equippedElement.appendChild(document.createElement("br"));
                });
            }
            
            lastHits = [];
            updateDPSDisplay();
        }

        function updateRecipesDisplays(){
            const craftDisplay = document.getElementById("craftDisplay");
            const recipeDisplay = document.getElementById("recipeDisplay");
            craftDisplay.innerHTML = "";
            recipeDisplay.innerHTML = "";
            const craftableRecipesWithIndex = recipes
                .map((recipe, idx) => [recipe, idx]).filter(([recipe]) => 
                recipe.materials.every(material => {
                    const item = inventory.items.find(i => i.name == material.name);
                    return item && item.quantity >= material.quantity;
                }));
            const learnedRecipesWithIndex = recipes
                .map((recipe, idx) => [recipe, idx]).filter(([recipe]) => 
                recipe.materials.every(material => {
                    const item = knownItems.has(material.name);
                    return item;
                }));

            craftDisplay.innerHTML +=
                craftableRecipesWithIndex
                .map(([item, originalIndex]) =>
                    `Craft: <span style="color: ${item.output.color}; cursor: pointer;"
                    onmousedown="inventory.craftItem(recipes[${originalIndex}]); updateRecipesDisplays(); updateInventory();">
                    ${item.output.name}</span> ` +
                    `<em>(${item.materials.join(", ")})</em>`
                )
                .join("<br>");
            recipeDisplay.innerHTML +=
                learnedRecipesWithIndex
                .map(([item, originalIndex]) =>
                    `Recipe: <span style="color: ${item.output.color};">
                    ${item.output.name}</span> ` +
                    `<em>(${item.materials.join(", ")})</em>`
                )
                .join("<br>");
            
            document.getElementById("crafting-content").style.display = craftDisplay.innerHTML === "" ? "none" : "block";
            if (document.getElementById("recipe-content").style.display != "none") document.getElementById("recipe-content").style.display = recipeDisplay.innerHTML === "" ? "none" : "block";
            if (document.getElementById("crafting-content").style.display === "none" && recipeDisplay.innerHTML != "") document.getElementById("recipe-content").style.display = "block";
            document.getElementById("recipeToggle").innerHTML = craftDisplay.style.display === "none" ? "Show Recipes" : "Hide Recipes";  
        }

        function updateEquipSelect() {
            const select = document.getElementById("equipSelect");
            const previousValue = select.value;

            select.innerHTML = "";

            const equippables = inventory.items.filter(item => item.equippable).sort((a, b) => a.equippable.localeCompare(b.equippable));
            for (const item of equippables) {
                let option = document.createElement("option");
                option.value = item.name;
                option.text = `${item.equippable} - ${item.name} (${item.quantity})`;
                select.add(option);
            }

            if (previousValue && Array.from(select.options).some(opt => opt.value === previousValue)) {
                select.value = previousValue;
            } else if (select.options.length > 0 && !select.value) {
                select.selectedIndex = 0;
            }
        }

        function updateWorldSelect(){
            const select = document.getElementById("worldSelect");
            const previousValue = select.value;

            select.innerHTML = "";

            let worlds = [];
            // default world
            worlds.push(WORLD_DEFS["Default World"]);

            // default world part 2
            let dirtyShoes = inventory.items.find(i => i.name == "Dirty Shoes");
            if (dirtyShoes && (dirtyShoes.quantity >= 10 || (dirtyShoes.quantity >= 9 && itemEquipped("Dirty Shoes")))){
                worlds.push(WORLD_DEFS["Default World (Part 2)"]);
            }

            // spirit world
            if (itemEquipped("Spectral Cowl") || itemEquipped("Skullstompers") || itemEquipped("Activated Gemstone Amulet")){
                worlds.push(WORLD_DEFS["Spirit World"]);
            }
            // desert world
            if (level >= 8){
                worlds.push(WORLD_DEFS["Desert World"]);
            }

            let hellItem = inventory.items.find(i => i.name == "Symbol of the Desert");
            if (hellItem){
                worlds.push(WORLD_DEFS["Hell World"]);
            }

            let mountainItem1 = inventory.items.find(i => i.name == "Memento of the Vulture");
            let mountainItem2 = inventory.items.find(i => i.name == "Memento of the Dino");
            let mountainItem3 = inventory.items.find(i => i.name == "Memento of the Fangtooth");
            let mountainItem4 = inventory.items.find(i => i.name == "Memento of the Succubus");
            let mountainItem5 = inventory.items.find(i => i.name == "Memento of the Insect");
            let mountainItem6 = inventory.items.find(i => i.name == "Memento of the Bovine");

            let hasPromiseRing = itemEquipped("Promise Ring") || inventory.items.find(i => i.name == "Promise Ring");

            if (mountainItem1 && mountainItem2 && mountainItem3 && mountainItem4 && mountainItem5 && mountainItem6 && hasPromiseRing){
                worlds.push(WORLD_DEFS["Ice World"]);
            }

            if (level >= 15){
                worlds.push(WORLD_DEFS["Dragon Swamp World"]);
            }

            let platinumCoins = inventory.items.find(i => i.name == "Platinum Coin");
            if (platinumCoins){
                worlds.push(WORLD_DEFS["Gold World"]);
            }

            // magic world
            let firstSeal = inventory.items.find(i => i.name == "First Seal");
            let secondSeal = inventory.items.find(i => i.name == "Second Seal");
            if (firstSeal && secondSeal){
                worlds.push(WORLD_DEFS["Arcane World"]);
            }

            // magic world part 2
            let thirdSeal = inventory.items.find(i => i.name == "Third Seal");
            let fourthSeal = inventory.items.find(i => i.name == "Fourth Seal");
            let fifthSeal = inventory.items.find(i => i.name == "Fifth Seal");
            let sixthSeal = inventory.items.find(i => i.name == "Sixth Seal");
            let seventhSeal = inventory.items.find(i => i.name == "Seventh Seal");
            if (thirdSeal && fourthSeal && fifthSeal && sixthSeal && seventhSeal){
                worlds.push(WORLD_DEFS["Arcane World (Part 2)"]);
            }

            // space world
            let starJars = inventory.items.find(i => i.name == "Arcane Star Jar");
            if (starJars && starJars.quantity >= 10){
                worlds.push(WORLD_DEFS["Space World"]);
            }

            let universalCredit = inventory.items.find(i => i.name == "Universal Credit");

            if (universalCredit){
                if (universalCredit.quantity >= 10) worlds.push(WORLD_DEFS["Volcano Planet World"]);
                if (universalCredit.quantity >= 100) worlds.push(WORLD_DEFS["Pleasure World"]);
                if (universalCredit.quantity >= 500) worlds.push(WORLD_DEFS["A.M. World"]);
                if (universalCredit.quantity >= 1250) worlds.push(WORLD_DEFS["Stellar Remnant World"]);
            }

            // REWORK MYTH UNLOCK - LEVEL 100

            if (level >= 100){
                worlds.push(WORLD_DEFS["Myth World"]);
            }

            if (level >= 120){
                worlds.push(WORLD_DEFS["Titan Boss World"]);
            }

            for (const world of worlds) {
                let option = document.createElement("option");
                option.value = world.name;
                option.text = world.name;
                select.add(option);
            }

            if (previousValue && Array.from(select.options).some(opt => opt.value === previousValue)) {
                select.value = previousValue;
            } else if (select.options.length > 0 && !select.value) {
                select.selectedIndex = 0;
            }
        
        }

        function updateFocus(){
            const select = document.getElementById("enemySelect");
            const previousValue = select.value;

            select.innerHTML = "";

            let enemyNames = [];
            enemyNames.push("None");
            let worldEnemies = WORLD_DEFS[worldSelect.value].enemies;
            worldEnemies.sort((a,b) => (ENEMY_DEFS[a].mobLevel - ENEMY_DEFS[b].mobLevel));
            for (const enemyName of worldEnemies){
                enemyNames.push(enemyName);
            }
            //console.log(enemyNames);
            for (const enemyName of enemyNames) {
                let option = document.createElement("option");
                option.value = enemyName;
                option.text = enemyName;
                select.add(option);
            }

            if (previousValue && Array.from(select.options).some(opt => opt.value === previousValue)) {
                select.value = previousValue;
            } else if (select.options.length > 0 && !select.value) {
                select.selectedIndex = 0;
            }
        }

        function updateUnequipSelect() {
            const select = document.getElementById("unequipSelect");
            const previousValue = select.value;

            select.innerHTML = "";

            for (const item of equipped) {
                let option = document.createElement("option");
                option.value = item.name;
                option.text = item.equippable + " - " + item.name;
                select.add(option);
            }

            if (previousValue && Array.from(select.options).some(opt => opt.value === previousValue)) {
                select.value = previousValue;
            } else if (select.options.length > 0 && !select.value) {
                select.selectedIndex = 0;
            }
        }

        function addToLastHits(damage){
            lastHits.push(damage);
            if (lastHits.length > 100){
                lastHits.shift();
            }
        }

        function updateEntityDisplay(lastHit = -1) {
            const display = document.getElementById("entityDisplay");
            display.innerHTML = ""; // clear previous content

            let entityName = document.createElement("strong");
            entityName.id = "entityName";
            entityName.textContent = activeEntity.name;
            display.appendChild(entityName);


            let entityLevel = document.createElement("strong");
            entityLevel.id = "entityLevel";
            entityLevel.textContent = " (" + activeEntity.mobLevel + ")";
            display.appendChild(entityLevel);

            display.appendChild(document.createElement("br"));

            let entityHP = document.createElement("strong");
            entityHP.id = "entityHP";
            entityHP.textContent = activeEntity.HP;
            display.appendChild(entityHP);

            if (lastHit > -1) {
                display.appendChild(document.createTextNode(" "));

                let entityDamage = document.createElement("span");
                entityDamage.id = "entityLastHit";

                if (activeEntity.armor > 0 && lastHit - activeEntity.armor > 0) {
                    entityDamage.innerHTML = `(-${lastHit - activeEntity.armor}) <em>(${lastHit} dmg, ${activeEntity.armor} armor)</em>`;
                } else if (activeEntity.armor > 0){
                    entityDamage.innerHTML = `(-0) <em>(${lastHit} dmg, ${activeEntity.armor} armor)</em>`;
                } else {
                    entityDamage.innerHTML = `(-${lastHit})`;
                }

                display.appendChild(entityDamage);
                addToLastHits(lastHit);
            }
            document.getElementById("entityLevel").style.color = "";
            if (level > activeEntity.mobLevel) document.getElementById("entityLevel").style.color = "#c5c5c5ff";
            document.getElementById("knownWorlds").innerHTML = `${knownWorlds.size} / ${Object.keys(WORLD_DEFS).length}`;
            updateDPSDisplay();
            updateDropTableDisplay();
        }

        function updateDropTableDisplay() {
            const dropTable = activeEntity.lootTable;

            const sortedItems = dropTable.items.slice().sort((a, b) => {
                const aI = dropTable.items.indexOf(a);
                const bI = dropTable.items.indexOf(b);
                return dropTable.weights[bI] - dropTable.weights[aI];
            });

            const intersection = sortedItems.filter(item => knownItems.has(item.name));

            const dropTableDisplay = document.getElementById("dropTableDisplay");
            dropTableDisplay.innerHTML = "";

            intersection.forEach(item => {
                const chance = truncateDecimal(100 * dropTable.getChance(item), 2);

                const wrapper = document.createElement("span");

                const chanceSpan = document.createElement("span");
                chanceSpan.textContent = `(${chance}%) `;
                chanceSpan.style.color = "";
                wrapper.appendChild(chanceSpan);

                const temp = { items: [item], list: Inventory.prototype.list };
                const itemFragment = temp.list.call({ items: [item] });
                wrapper.appendChild(itemFragment);

                dropTableDisplay.appendChild(wrapper);
                dropTableDisplay.appendChild(document.createElement("br"));
            });

            // Update entity name color
            const entityNameEl = document.getElementById("entityName");
            entityNameEl.style.color = (intersection.length === sortedItems.length) ? GOLD : "";
        }

        function updateDPSDisplay(){
            if (lastHits.length == 0){
                document.getElementById("dpsDisplay").innerHTML = "0 average dmg"
                return;
            }
            
            let cumDamage = 0;
            
            for (let i = 0; i < lastHits.length; i++){
                cumDamage += lastHits[i];
            }
            
            document.getElementById("dpsDisplay").innerHTML = Math.floor(cumDamage / lastHits.length) + " average dmg";
        }

        function equip(itemName){
            // console.log("trying to equip " + itemName);
            if (!inventory.items){
                return;
            }
            let item = inventory.items.find(i => i.name == itemName);
            if (!item){
                return;
            }
            if (!item.equippable){
                return;
            }

            for (let i of equipped){
                if (i.equippable == item.equippable){
                    inventory.addItem(Item.createItem(i.name, 1));
                    equipped = equipped.filter(e => e !== i);
                }
            }

            item.quantity -= 1;
            if(item.quantity == 0) inventory.items = inventory.items.filter(i => i.name !== itemName);

            equipped.push(Item.createItem(item.name, 1));
            // console.log("equipped " + itemName);
            updateInventory();
            updateEquipped();
            updateWorldSelect();
            computeLoadoutStats();
        }

        function itemEquipped(name){
            for (let i of equipped){
                if (i.name == name){
                    return true;
                }
            }
            return false;
        }

        function unequip(itemName){
            let item = equipped.find(i => i.name == itemName);
            if (!item){
                return;
            }
            equipped = equipped.filter(i => i != item);
            inventory.addItem(Item.createItem(item.name, 1));
            updateInventory();
            updateEquipped();
            updateWorldSelect();
            computeLoadoutStats();
        }

        function computeLoadoutStats() {
            let state = {
                dmg: 1,
                dmgMult: 1.0,
                moreMult: 1.0,
                missChance: 0.0,
                missMult: 0,
                arcaneCount: 0,
                arcaneSetBonus: 0,
                starSetBonus: 0,
                setBase: -1,
            };

            for (let i of equipped) {
                if (ItemStaticEffects[i.name]) {
                    ItemStaticEffects[i.name](state);
                    continue;
                }
            }

            state.dmg += state.starSetBonus * state.starSetBonus * 25;
            state.dmgMult += state.arcaneCount * state.arcaneSetBonus * 0.03;

            if (state.setBase !== -1) state.dmg = state.setBase;

            precomputedDamage = {
                baseDmg: state.dmg,
                dmgMult: state.dmgMult,
                moreMult: state.moreMult,
                missChance: state.missChance,
                missMult: state.missMult,
                arcaneCount: state.arcaneCount,
                arcaneSetBonus: state.arcaneSetBonus,
                starSetBonus: state.starSetBonus,
                setBase: state.setBase,
            };
            }

        function itemInSlot(slot){
            for (let item of equipped){
                if (item.equippable == slot){
                    return item;
                }
            }
            return null;
        }

        function saveGame() {
            const saveData = {
                items: inventory.serialize(),
                knownItems: Array.from(knownItems),
                knownWorlds: Array.from(knownWorlds),
                equipped: equipped,
                level: level,
                xp: experience,
                volume: volume,
            };
            localStorage.setItem("clickerGameInfo", JSON.stringify(saveData));
        }

        function loadGame() {
            const savedDataString = localStorage.getItem("clickerGameInfo");
            if (savedDataString) {
                const savedData = JSON.parse(savedDataString);
                localStorage.setItem("clickerGameInfo", savedDataString);
                equipped = savedData.equipped || [];
                autoMode = false;

                inventory = new Inventory();
                inventory.load(savedData.items || []);

                level = savedData.level || 0;
                experience = savedData.xp || 0;
                gainExperience();

                knownItems.clear();
                knownWorlds.clear();
                if (savedData.knownItems) {
                    for (const item of savedData.knownItems) {
                        knownItems.add(item);
                    }
                }
                if (savedData.knownWorlds) {
                    for (const world of savedData.knownWorlds) {
                        knownWorlds.add(world);
                    }
                }
                volume = savedData.volume || 50;
                document.getElementById("volumeSlider").value = volume;
            } else {
                inventory = new Inventory();
            }
            updateInventory();
            updateEquipped();
            updateWorldSelect();
            computeLoadoutStats();
        }
        

        let worldTimer = 0;
        setInterval(() => {
            worldTimer++;
            let alert_message = `You have been in ${worldSelect.value} for ${worldTimer} seconds (${Math.floor((kills/worldTimer)*60*60)} kills/h)`;
            document.getElementById("worldTimer").textContent = alert_message;
        }, 1000);
        document.getElementById("worldTimer").textContent = "You have been in Default World for 0 seconds";

        // const musicPlayer = new Audio();
        // musicPlayer.loop = true;
        // function playMusic(){
        //     musicPlayer.pause();
        //     if (worldMusic[worldSelect.value]) {
        //         musicPlayer.src = worldMusic[worldSelect.value];
        //         musicPlayer.currentTime = 0;
        //         musicPlayer.play();
        //     }
            
        // }

        worldSelect.addEventListener("change", () => {
            worldTimer = 0;
            kills = 0;
            activeEntity = randomEnemy(worldSelect.value);
            knownWorlds.add(worldSelect.value);
            updateFocus();
            updateEntityDisplay();
            // playMusic();
        });

        // musicPlayer.onerror = (e) => {
        //     console.error("Audio playback error", e);
        // };

        document.getElementById("volumeSlider").addEventListener("change", () => {
            volume = document.getElementById("volumeSlider").value;
            // musicPlayer.volume = volume / 100.0;
        })

        window.onload = loadGame;
        window.onbeforeunload = saveGame;

        loadGame();
        updateInventory();
        updateEquipped();
        updateWorldSelect();
        // playMusic();
        // musicPlayer.volume = volume / 100.0;
    </script>

    <script>
        let textTimer;
        function hit(){
            let hit = attackDamage();
            let loot;
            activeEntity.damage(hit);
            attackCount++;
            enemyAttacks++;
            if (activeEntity.destroyed){
                if (loot = activeEntity.getLoot(dropCount)){
                    document.getElementById("lootDisplay").innerHTML = "Got: ";
                    for (let item of loot){
                        inventory.addItem(item);
                        document.getElementById("lootDisplay").innerHTML +=  item.quantity + "x" + `<span style="color: ${item.color}"> ${item.name} </span>`;
                    }
                    if (textTimer) clearTimeout(textTimer);
                    textTimer = setTimeout(() => {
                        document.getElementById("lootDisplay").innerHTML = "";
                        textTimer = null;
                    }, 6000);
                }
                gainExperience(activeEntity);
                activeEntity = randomEnemy(worldSelect.value);
                enemyAttacks = 0;
                kills++;
                updateInventory();
            } 

            updateEntityDisplay(hit);
        }
    </script>

    <script>
        document.getElementById("equipButton").addEventListener("click", () => {
            this.equip(document.getElementById("equipSelect").value);
            // console.log(equipped);
        });
        document.getElementById("unequipButton").addEventListener("click", () => {
            this.unequip(document.getElementById("unequipSelect").value);
        });
        // document.getElementById("saveButton").addEventListener("click", () => {
        //     saveGame();
        // });
        document.getElementById("resetButton").addEventListener("click", () => {
            if (confirm("Are you sure you want to reset your sava data? This cannot be undone.")) {
                inventory = new Inventory();
                equipped = [];
                
                autoMode = false;
                document.getElementById("attackButton").innerHTML = "Attack!";
                clearInterval(autoInterval);
                knownItems.clear();
                knownWorlds.clear();
                
                experience = 0;
                level = 0;
                updateWorldSelect();
                activeEntity = randomEnemy(worldSelect.value);
                updateEntityDisplay(-1);
                updateRecipesDisplays();
                saveGame();
                loadGame();
            }
        });
        document.addEventListener("mousemove", e=> {
            const tooltip = document.getElementById("tooltip");
            tooltip.style.left = (e.pageX + 6) + "px";
            tooltip.style.bottom = (window.innerHeight - e.pageY + 6) + "px";
        })
        document.getElementById("attackButton").addEventListener("click", () => {
            autoMode = !autoMode;
            if (autoMode){
                document.getElementById("attackButton").innerHTML = "Stop Attacking";
                autoInterval = setInterval(() => {
                    hit();
                }, 500);
            } else {
                document.getElementById("attackButton").innerHTML = "Attack!";
                clearInterval(autoInterval);
            }
        });
        document.getElementById("recipeToggle").addEventListener("click", () => {
            if (document.getElementById("recipe-content").style.display === "none"){
                document.getElementById("recipe-content").style.display = "block";
                document.getElementById("recipeToggle").innerHTML = "Hide Recipes";
            } else {
                document.getElementById("recipe-content").style.display = "none";
                document.getElementById("recipeToggle").innerHTML = "Show Recipes";
            }
        });
    </script>

    <script>
        function attackDamage() {
            let state = {
                dmg: precomputedDamage.baseDmg,
                dmgMult: precomputedDamage.dmgMult,
                moreMult: precomputedDamage.moreMult,
                missChance: precomputedDamage.missChance,
                missMult: precomputedDamage.missMult,
                armorBreak: 0,
                armorBreakMod: 1.00,
                attackCount,
                enemyAttacks,
                inventory,
                activeEntity
            };

            for (const i of equipped) {
                const effect = ItemEffects[i.name];
                if (effect) effect(state);
            }

            if (Math.random() < state.missChance) state.dmg *= state.missMult;
            state.armorBreakMod *= 10;
            return Math.floor(
                Math.max(0, state.dmg) *
                Math.max(0.0, state.dmgMult) *
                Math.max(0.0, state.moreMult) +
                Math.min(Math.max(0.0, state.armorBreak) * Math.max(0.0, state.armorBreakMod), state.activeEntity.armor)
            );
        }
        
    </script>

    <script>
        function randomEnemy(worldName){
            let world = WORLD_DEFS[worldName];
            const focusedEnemyName = document.getElementById("enemySelect").value;
            document.body.style.backgroundColor = world.worldColor;
            let enemyList = [];
            for (let i = 0; i < world.enemies.length; i++){
                enemyList.push(world.enemies[i]);
            }
            if (focusedEnemyName != "None"){
                enemyList.push(focusedEnemyName);
            }
            if (itemEquipped("Greedy Goldgrubber Grips")){
                enemyList.push("Treasure Goblin");
            }
            let enemy = spawnEnemy(enemyList[Math.floor(Math.random() * enemyList.length)]);
            //console.log("of " + enemyList + " chose" + enemy.name);
            document.getElementById("xpText").style.color = "";
            if (enemy.mobLevel < level){
                document.getElementById("xpText").style.color = "#c5c5c5ff";
            }
            return enemy;
        }
    </script>

    <script>
        updateFocus();
        knownWorlds.add(worldSelect.value);
        activeEntity = randomEnemy(worldSelect.value);
        updateEntityDisplay(-1);
    </script>

</body>
</html>